# **Desafíos Diarios de Programación**

¡Bienvenido al repositorio de Desafíos Diarios de Programación! 🎉 **Puedes elegir los lenguajes y Herramientas que desees**.

Cada Mini Challenge tiene un valor de **50 PenguPoints**. Recuerda que para ganar PenguPoints por Mini Challenges debes cumplir los siguiente requisitos:

- Debes registrar tu progreso subiendo tus ejercicios al typeform de entrega https://penguinacademy.typeform.com/to/wdFfjXZf
- El código presentado debe ser funcional
- El código presentado debe cumplir con lo solicitado por el ejercicio

## **¡Manos a la obra!** 😎

1. **Búsqueda en lista ordenada:** Implementa una función de búsqueda binaria que determine si un número está en una lista ordenada de 10 elementos.

   ---

2. **Ordenamiento simple:** Escribe una función que ordene una lista de 5 enteros utilizando cualquier método de ordenamiento que prefieras (por ejemplo, burbuja, inserción, selección).

   ---

3. **Recorrido en profundidad (DFS):** Implementa un recorrido DFS para un grafo simple con 5 nodos.

   ---

4. **Recorrido en amplitud (BFS):** Implementa un recorrido BFS para un grafo simple con 5 nodos.

   ---

5. **Camino más corto:** Dado un grafo pequeño con 5 nodos y 6 aristas, escribe una función que encuentre el camino más corto entre dos nodos especificados usando cualquier método que prefieras.

   ---

6. **Árbol binario de búsqueda (BST):** Implementa solo la inserción en un árbol binario de búsqueda para 5 elementos.

   ---

7. **Piloto de eventos (Priority Queue):** Implementa una cola de prioridad utilizando una lista para insertar y eliminar 5 elementos.

   ---

8. **Pilas y colas:** Implementa las operaciones básicas de una pila y/o una cola para 5 elementos.

   ---

9. **Recursión Factorial:** Implementa una función recursiva para calcular el factorial de un número pequeño (por ejemplo, 5).

   ---

10. **Eliminar duplicados:** Implementa una función que elimine los elementos duplicados de una lista de 10 enteros.

   ---

11. **Clase de Punto 2D:** Crea una clase `Punto2D` con atributos `x` & `y`, y un método para imprimir sus coordenadas.

   ---

12. **Figura y Círculo:** Crea una clase base `Figura` con un método `imprimir` y una clase derivada `Círculo` que extienda `Figura` y sobreescriba el método `imprimir`.

   ---

13. **Cuenta bancaria:** Implementa una clase `CuentaBancaria` con métodos para depositar y consultar el saldo.

   ---

14. **Polimorfismo:** Crea una clase base `Animal` con un método `hacerSonido` y una clase derivada `Perro` que sobrescriba este método.

   ---

15. **Auto y Motor:** Implementa una clase `Auto` que contenga una instancia de una clase `Motor` con un método para describir el motor.

   ---

16. **Formas geométricas:** Define una clase base `FormaGeometrica` con métodos `calcular_area` y `calcular_perimetro`. Crea clases derivadas `Rectangulo` y `Circulo` que sobrescriban estos métodos.

   ---

17. **Creación de tabla:** Escribe una consulta SQL para crear una tabla `Usuarios` con columnas `id` y `nombre`.

   ---

18. **Inserción de datos:** Escribe una consulta SQL para insertar un solo registro en la tabla `Usuarios`.

   ---

19. **Consulta básica:** Escribe una consulta SQL para seleccionar todos los registros de la tabla `Usuarios`.

   ---

20. **Actualizar registros:** Escribe una consulta SQL para actualizar el nombre de un usuario específico en la tabla `Usuarios`.

   ---

21. **Eliminar registros:** Escribe una consulta SQL para eliminar un usuario específico de la tabla `Usuarios`.

   ---
# Mini Challenge Grande 
## 100 puntos por completarlo satisfactoriamente y 500 puntos al algoritmo mas eficiente

¡Bienvenidos al reto **Benchmarking de Eficiencia Algorítmica**!

En este reto, implementarán y optimizarán el algoritmo de **QuickSort**, enfocándose en su eficiencia en términos de uso de memoria y velocidad de ejecución. Puedes usar cualquier lenguaje de programación de tu elección (Python, JavaScript, C++, etc.). El objetivo es producir la implementación más eficiente posible.

## **Requisitos del Reto**

- **Datos de Entrada**:
  - Ordenarás arrays de enteros. Debes proporcionar tres conjuntos de datos de diferentes tamaños:
    - **Conjunto pequeño**: 100 elementos.
    - **Conjunto mediano**: 300 elementos.
    - **Conjunto grande**: 500 elementos.

- **Criterios de Evaluación**:
  - **Velocidad de Ejecución**: El tiempo que tarda tu implementación en ordenar los arrays.
  - **Uso de Memoria**: La cantidad de memoria utilizada durante la ejecución del algoritmo.
  - **Correctitud**: El algoritmo debe ordenar correctamente todos los elementos del array.
  - **Estabilidad**: Mantener el orden relativo de los elementos con valores iguales (opcional, pero valorado).

- **Requisitos Específicos**:
  - Implementa la versión estándar de QuickSort.
  - Mide el tiempo de ejecución y uso de memoria utilizando herramientas adecuadas para el lenguaje de programación que elijas.
  - Asegúrate de que tu implementación sea correcta y eficiente.

## **Entrega**

- Comparte el link de tu repositorio en el siguiente link https://penguinacademy.typeform.com/to/zdW0eV0e 

## **Evaluación**

- Serán evaluados en función de:
  - La eficiencia de su implementación (velocidad y uso de memoria).
  - La correctitud del algoritmo.

## **Ejemplo de Evaluación**

- **Conjunto Pequeño (100 elementos)**:
  - **Tiempo de Ejecución**: X ms
  - **Uso de Memoria**: Y MB

- **Conjunto Mediano (300 elementos)**:
  - **Tiempo de Ejecución**: A ms
  - **Uso de Memoria**: B MB

- **Conjunto Grande (500 elementos)**:
  - **Tiempo de Ejecución**: M ms
  - **Uso de Memoria**: N MB

## **Consejos de Optimización**

- Utiliza técnicas de recursión eficiente o iteración en lugar de recursión profunda.
- Evita el uso excesivo de memoria adicional.
- Asegúrate de tener un control eficiente sobre las iteraciones para evitar bucles innecesarios y redundantes.

¡Buena suerte y que gane la implementación más eficiente!



